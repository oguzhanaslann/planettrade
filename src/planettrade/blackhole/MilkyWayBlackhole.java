package planettrade.blackhole;

import planettrade.LightYear;
import planettrade.galaxy.Galaxy;
import planettrade.galaxy.Milkyway;
import planettrade.logger.Logger;
import planettrade.market.MarketGenerator;
import planettrade.planet.DistanceTable;
import planettrade.planet.Planet;
import util.NumberUtils;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.stream.IntStream;

public class MilkyWayBlackhole implements Blackhole {

    private MarketGenerator marketGenerator;

    public MilkyWayBlackhole(MarketGenerator marketGenerator) {
        this.marketGenerator = marketGenerator;
    }

    @Override
    public Galaxy explode() {
        Logger.info("MilkyWayBlackhole explodes - KABOOM!");
        Set<Planet> planets = randomPlanets();
        Logger.release("R-15 At each planet a random market containing random supply of the commodities are generated by a market generator.");
        Logger.debug("MilkyWayBlackhole: random planets created: " + planets);
        Logger.debug("MilkyWayBlackhole: Total planets: " + planets.size());
        Map<Planet, Map<Planet, LightYear>> distances = randomDistances(planets);
        DistanceTable distanceTable = new DistanceTable(distances);
        Logger.debug("MilkyWayBlackhole: random distances created: " + distances);
        return new Milkyway(planets, distanceTable);
    }

    private Set<Planet> randomPlanets() {
        HashSet<Planet> planets = new HashSet<>();
        // random size
        int planetCount = NumberUtils.random(2, 10);
        IntStream
                .range(1, planetCount)
                .mapToObj(this::randomPlanet)
                .forEach(planets::add);
        return planets;
    }

    private Planet randomPlanet(int i) {
        return Planet.random(marketGenerator);
    }

    /**
     * distances between planets, not including the planet itself
     */
    private Map<Planet, Map<Planet, LightYear>> randomDistances(Set<Planet> planets) {
        HashMap<Planet, Map<Planet, LightYear>> distances = new HashMap<>();


        for (Planet planet : planets) {
            distances.put(planet, new HashMap<>());
            Set<Planet> others = planets.stream()
                    .filter(p -> !p.equals(planet))
                    .collect(HashSet::new, HashSet::add, HashSet::addAll);
            for (Planet other : others) {
                if (distances.containsKey(other) && distances.get(other).containsKey(planet)) {
                    Map<Planet, LightYear> calculatedDistanceMap = distances.get(other);
                    LightYear calculatedDistance = calculatedDistanceMap.get(planet);
                    Map<Planet, LightYear> planetDistances = distances.getOrDefault(planet, new HashMap<>());
                    planetDistances.put(other, calculatedDistance);
                    distances.put(planet, planetDistances);
                } else {
                    LightYear distance = LightYear.random(100, 1000);
                    Map<Planet, LightYear> planetDistances = distances.getOrDefault(planet, new HashMap<>());
                    planetDistances.put(other, distance);
                    distances.put(planet, planetDistances);
                }
            }
        }
        return distances;
    }
}
